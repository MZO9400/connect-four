{"version":3,"file":"static/js/657.625308aa.chunk.js","mappings":"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","sources":["exception/FilledRowException.ts","types/Color.ts","Game/API.ts","Player/AI.ts"],"sourcesContent":["class FilledRowException extends Error {\n    constructor(message: string) {\n        super('FilledRowException: ' + message)\n    }\n}\n\n\nexport default FilledRowException","enum Color {\n    NONE = \"none\",\n    RED = \"red\",\n    YELLOW = \"yellow\"\n}\n\nexport default Color;","import FilledRowException from \"../exception/FilledRowException\";\nimport Color from \"../types/Color\";\n\nexport const getNextBoard = (grid: Color[][], col: number, turn: Color): Color[][] => {\n    const newGrid = grid.map(val => val.slice())\n    \n    const rowNumber: number = grid[col].findIndex(value => value === Color.NONE)\n    if (rowNumber === -1) {\n      throw new FilledRowException(`Column ${col} has no empty rows`);\n    }\n    newGrid[col][rowNumber] = turn === Color.YELLOW ? Color.YELLOW : Color.RED;\n    return newGrid;\n}\n\nexport const checkWin = (grid: Color[][], column: number, row: number): Color => {\n    const columnCheck = grid[column].slice(Math.max(row - 4, 0), 4);\n\n    const rowCheck: Color[] = []\n    const diagonalLeftCheck: Color[] = []\n    const diagonalRightCheck: Color[] = []\n    for (let i = column - 3; i <= column + 3; i++) {\n      const currentDiagonalDistance = Math.abs(column - i);\n      const rowNeg = row - currentDiagonalDistance\n      const rowPos = row + currentDiagonalDistance\n      try {\n        diagonalLeftCheck.push(grid[i][i <= 0 ? rowPos : rowNeg])\n      } catch (e) {}\n      try {\n        diagonalRightCheck.push(grid[i][i <= 0 ? rowNeg : rowPos])\n      } catch (e) {}\n      try {\n        rowCheck.push(grid[i][row]);\n      } catch (e) {}\n    }\n    if (hasConsecutive(columnCheck, 4) || hasConsecutive(rowCheck, 4) || hasConsecutive(diagonalLeftCheck, 4) || hasConsecutive(diagonalRightCheck, 4)) {\n        return grid[column][row];\n    }\n    return Color.NONE\n}\n\nconst hasConsecutive = (array: Color[], checkCount: number): boolean => {\n    return array.reduce((acc, i, ind) => {\n        const slice = array.slice(Math.max(ind - checkCount, 0), checkCount)\n        if (slice.length === checkCount && slice.every(value => value === i) && [Color.RED, Color.YELLOW].includes(i)) {\n            return true\n        }\n        return acc\n    }, false)\n}","/* eslint-disable no-restricted-globals */\nimport { checkWin } from \"../Game/API\";\nimport Color from \"../types/Color\";\nimport { getNextBoard } from \"../Game/API\";\n\ninterface MinMaxValue {\n    score: number,\n    move: number\n}\n\nconst MAX_DEPTH = 3\n\n\nself.onmessage = function (event) {\n    const {grid, forPlayer} = event.data\n    self.postMessage(getBestMove(grid, forPlayer));\n  };\n\nconst getBestMove = (grid: Color[][], forPlayer: Color): number => {\n   return minimax(grid, forPlayer, forPlayer).move\n}\n\n\nconst minimax = (grid: Color[][], forPlayer: Color,  playerToMove: Color, depth: number = 0): MinMaxValue => {\n    const winner = getWinner(grid)\n    if (winner !== Color.NONE) {\n        return {score: score(winner, playerToMove), move: -1}\n    }\n\n    if (depth > MAX_DEPTH) {\n        return {score: 0, move: -1}\n    }\n\n    const moves: number[] = []\n    const scores: number[] = []\n\n    const availableMoves = getAvailableMoves(grid).sort((a, b) => 0.5 - Math.random())\n\n    availableMoves.forEach(move => {\n        const possibleGame: Color[][] = getNextBoard(grid, move, playerToMove);\n        const nextPlayer: Color = Color.RED === playerToMove ? Color.YELLOW : Color.RED\n        moves.push(move)\n        scores.push(minimax(possibleGame, forPlayer, nextPlayer, depth + 1).score)\n    })\n\n    if (forPlayer === playerToMove) {\n        let maxScore = -10000\n        let maxScoreIdx: number = -1\n        for (let i = 0; i < scores.length; i++) {\n            if (scores[i] >= maxScore) {\n                maxScore = scores[i]\n                maxScoreIdx = i;\n            }\n        }\n        return {score: maxScore, move: moves[maxScoreIdx]}\n    } else {\n        let minScore = +10000\n        let minScoreIdx: number = -1\n        for (let i = 0; i < scores.length; i++) {\n            if (scores[i] <= minScore) {\n                minScore = scores[i]\n                minScoreIdx = i;\n            }\n        }\n        return {score: minScore, move: moves[minScoreIdx]}\n    }\n}\n\nconst getAvailableMoves = (grid: Color[][]): number[] => {\n    const moves: number[] = []\n    grid.forEach((column, columnIndex) => {\n        if (column.includes(Color.NONE)) {\n            moves.push(columnIndex)\n        }\n    })\n    return moves;\n}\n\nconst score = (winner: Color, forPlayer: Color): number => {\n    switch (winner) {\n        case Color.NONE:\n            return 0;\n        case forPlayer:\n            return 10;\n        default:\n            return -10;\n    }\n}\n\nconst getWinner = (grid: Color[][]): Color => {\n    let winner = Color.NONE\n    for (let col = 0; col < grid.length; col++) {\n        const row = grid[col].findIndex(i => i !== Color.NONE)\n        winner = checkWin(grid, col, row);\n        if (winner !== Color.NONE) {\n            break;\n        }\n        if (winner !== Color.NONE) {\n            break;\n        }\n    }\n    return winner;\n}\n\n\nexport {}"],"names":["FilledRowException","Error","constructor","message","super","Color","checkWin","grid","column","row","columnCheck","slice","Math","max","rowCheck","diagonalLeftCheck","diagonalRightCheck","i","currentDiagonalDistance","abs","rowNeg","rowPos","push","e","hasConsecutive","NONE","array","checkCount","reduce","acc","ind","length","every","value","RED","YELLOW","includes","self","onmessage","event","forPlayer","data","postMessage","getBestMove","minimax","move","playerToMove","depth","arguments","undefined","winner","getWinner","score","moves","scores","getAvailableMoves","sort","a","b","random","forEach","possibleGame","getNextBoard","col","turn","newGrid","map","val","rowNumber","findIndex","concat","nextPlayer","maxScore","maxScoreIdx","minScore","minScoreIdx","columnIndex"],"sourceRoot":""}